# Отчет по лабораторной работе N 23 по курсу
# "Фундаментальная информатика"

Студент группы: M8О-115Б, Шаталов Максим Алексеевич\
Контакты: rcmakism@mail.ru \
Работа выполнена: 20.03.2024\
Преподаватель: Чеснов Илья Игоревич

## 1. Тема

Динамические структуры данных. Обработка деревьев.

## 2. Цель работы

Составить программу на языке C для построения дерева общего вида или упорядоченного двоичного дерева.

## 3. Задание

Определить уровень дерева, на котором находится максимальное число вершин.

## 4. Оборудование

Процессор: Intel Core i5-8265U @ 8x 3.9GH\
ОП: 7851 Мб\
НМД: 1024 Гб\
Монитор: 1920x1080

## 5. Программное обеспечение

Операционная система семейства: **linux (ubuntu)**, версия **18.10 cosmic**\
Интерпретатор команд: **bash**, версия **4.4.19**.\
Система программирования: **--**, версия **--**\
Редактор текстов: **emacs**, версия **25.2.2**\
Утилиты операционной системы: **--**\
Прикладные системы и программы: **--**\
Местонахождение и имена файлов программ и данных на домашнем компьютере: **--**

## 6. Идея, метод, алгоритм решения задачи

Необходимо реализовать структуру дерево с функциями его изменения. Добавление вершины, удаление вершины, вывод дерева и вычисление функции подсчета уровня дерева, на котором находится максимальное число вершин. Опишем идею каждого пункта.
Для подсчета подсчёта колличества вершин на каждом из уровней, введем динамическую структуру уровни, она будет хранить: номер уровня, колличество вершин, ссылку на следущий уровень.
Для реализации графа будем использовать динамическую структуру каждый элемент который будет структурой которая будет хранить номер вершины, ссылка на сына, ссылку на брата и ссылку на уровень( на котором расположена вершина).
Тогда на всю структуру дерева будет указывать ссылка на самый первый элемент дерева(корень).
1. Функция создания новой вершины должна пробежаться по дереву, найти необходимого родителя и к нему подцепиться. Если у родителя нет сыновей, то новая вершина станет первым сыном, иначе нужно пробежаться по братьям и добавиться к самому младшему. При добавлении необходимо забрать ссылку на уровень от брата или от родителя, но тогда уровень новой вершины будет равен next у уровня родителя.
2. Функция удаления должна изменить колличество вершин на соответствующем уровне, если на уровне стало 0 вершин, то нужно удалить уровень. Далее нужно освободить память занимаему самой вершиной и её потомство, используя рекурсивный подход.
3. Функция печати графа -- рекурсивная функция которая будет знать текущий уровень и печатать с колличеством отступов равным номеру уровня значение текущей вершины. Используюя рекурсивный подход можно получить красивый вывод дерева.
4. Функция подсчета уровня содержащего максимальное число вершин реализована очень просто, благодаря тому, что каждая вершина имеет сслыку на свой уровень. При таком подходе достаточно пройтись по ссылке next каждого уровня от превого указателя на уровень 0, до последнего, чей next = NULL. На всём пути считаем MAX, поле прохода по всем уровням выводим получившийся результат.
5. Далее реализуем функции вывода подсказки при вводе ? и функцию завершения обработки ввода при вводе q.

## 7. Сценарий выполнения работы

Создаём две структуры
1. вершина node, она хранит номер вершины, указатель типа node на сына, указатель типа node на брата и указатель типа node на уровень( на котором расположена вершина)
2. уровень level, хранит номер уровня, колличество вершин, указатель типа level на следущий уровень

Функция print_info выводит командами printf информацию о использовании программы

Для работы функции add(добавление вершины) и rm(удаление вершины) необходима функция find. find принимает родителя вершины которую мы хотим создать и рекурсивно проходится по графу с помощью алгоритма поиска в глубину и возвращает указатель типа node на элемент к которому мы поддепим ново-созданную вершину. Это может быть и брат и родитель в зависимости от существования брата.

Функция add проверяет есть ли корень. Если нет корня, то с помощью malloc выделяем память под новый node который станет вершиной. Задаем ребенка и брата NULL, а для уровня аналогично malloc создаем 0 уровень, ссылна next = NULL.
Если корень есть то с помощью find находим вершину к которой мы подцепимся, и дальше malloc-ом выделяем память под новую вершину. Задаем, чтобы вершина найденная функцией find ссылалась на ново созданую. У новосозданой брат и ребенок = NULL, а level равен уровню брата, или next уровню уровня родителя. Если уровня не существует, аналогично вершине с помощью malloc создаем новый уровень, на который будет ссылаться предыдущий. Колличество вершина будет равно 0. Теперь к колличеству точек на уровне на которы ссылается ново-созданая точка прибавляем еденицу.

Опишем функцию rm(удаления). Для работы rm нужна отдельная функция find которая будет возвращать вершину которая ссылается на ту, которую мы хотим удалить. Функция del_find работает аналогично find. После её вызова мы имеем вершину которая ссылается на удаляемую. Заменяем ссылки на NULL. И запускаем рекурсивную функцю которая проходится по поддереву и удаляет все вершины и вычитает еденичку из соответствующего уровня, если а на уровне осталось 0 вершин то уровень удаляется.

Опишем функцию вычисления функции подсчета уровня с максимальным числом вершин. Переходим на уровень 0 через ссылку на level от переданного header. Далеее пока не закнчились уровни переходим в next каждого следущего и подсчитываем максимум на пути. Выводим получившийся результат.

Опишем функцию печати дерева. Рекурсивная функция которая перейдет по графу каждый раз передавая текущий уровень. В ребенка передается текущий уровень + 1, а при переходе в брата уровень остается. На каждой вершине печатаем необходимое количество отступов и потом само значение вершины.

В главной функции считываем флаг необходмой операции(+ - f p q) и с помощью конечного автомата вызываем соответствующие функции работы с деревом.

## 8. Распечатка протокола

```
Тест 1

+ -1 1
1 added
+ 1 2
2 added
+ 2 3
3 added
+ 1 4
4 added
p
1
- 2
- - 3
- 4
f
Level with max count of vertex is - 1

Тест 2

+ -1 1
1 added
+ 1 2
2 added
+ 2 3
3 added
+ 1 5
5 added
p
1
- 2
- - 3
- 5
- 2
2 deleted
p
1
- 5

Тест 3

+ -1 3
3 added
+ 3 4
4 added
+ 3 9
9 added
+ 9 11
11 added
+ 9 12
12 added
+ 9 14
14 added
f
Level with max count of vertex is - 2
p
3
- 4
- 9
- - 11
- - 12
- - 14

```

## 9. Дневник отладки

| № | Лаб. или дом. | Дата       | Время     | Событие                  | Действие по исправлению | Примечание  |
|---|---------------|------------|-----------|--------------------------|-------------------------|-------------|
|1  | Дом           | 13.03.2023 | 13:50     | Обишка доступа к памяти    | Добавил проверку на NULL     | Ошибка логики|
|2  | Дом           | 14.03.2023 | 02:54     | Не удалялся level | добавил очистку памяти  | Не земетил |
|3  | Дом           | 14.03.2023 | 04:24     | два раза считывал команду | добавил break в case  | Невнимательность|

## 10. Замечания автора по существу работы

Было крайне интересно разбираться с указателями и выделением памяти в C. Malloc оказался довольно интересным.

## 11. Выводы

Я научился использовать динамическую структуру на ссылках, и понял, что free лучше malloc, и вообще память нужно использовать правильно.

